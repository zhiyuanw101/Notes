# C++面试题
## 虚函数，纯虚函数
允许被子类重新定义的成员函数（member function）
### 1. 虚函数
```c++
virtual returntype func(parameter);
```
动态绑定
### 2. 纯虚函数
```c++
virtual returntype func(parameter) = 0;
```
只是定义函数接口
### 3. [虚函数表](https://blog.csdn.net/lihao21/article/details/50688337)
- 虚表属于类，每个对象使用同一虚表，是一个指针数组
- 每个对象包含指向虚表的指针 `*__vptr`
- 虚表中函数指针指向其继承的最近的一个虚函数
- 虚表在编译时构造
### 4. 基类析构函数需要为虚函数
防止内存泄漏

## static使用
- 静态变量：局部变量前加static
    - 存入内存中static，程序运行中一直存在
    - 作用域：仍是函数块（局部作用域）
- 全局静态变量：全局变量前加static
    - 内存中static区
    - 作用域：声明的文件之外不可见
- 静态成员：static修饰类成员变量
    - 静态成员属于整个类
    - const修饰的在类内初始化，否则在类外初始化`int base::var = 10`
- 静态成员函数：static修饰成员函数
    - 所有对象共享这一函数，不含this指针
    - 不需要通过对象就可以访问
    - 表示该函数职能作用在类型的静态变量上

## const与#define
1. 编译器处理方式 
define – 在预处理阶段进行替换 
const – 在编译时确定其值

2. 类型检查 
define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
const – 有数据类型，编译时会进行类型检查

3. 内存空间 
define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

4. 其他 
在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 
宏替换只作替换，不做计算，不做表达式求解。